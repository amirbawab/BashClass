{
    "docs": [
        {
            "location": "/",
            "text": "Github\n\n\nLink: \nhttps://github.com/amirbawab/BashClass\n\n\nAbout\n\n\nBashClass is a programming language supporting Object Oriented Programming, and compiles into BASH 4.4. Classes and members written in BashClass are converted into associative arrays with unique indices in the generated BASH script. \n\n\nBashClass uses \nEasyCC-C++\n library which provides the lexical and syntax analysis. The lexical and syntax analysis configuration files, located under the resources directory, serve as input to EasyCC-C++ to parse the user files and validate it against a grammar determining the language syntax. \n\n\nBuild project\n\n\nDocker\n\n\n\n\nClone repository\n\n\nBuild image: \nsudo docker build -t bashclass:latest .\n\n\nRun container: \ndocker run --name bashclass-tutorial -it bashclass:latest\n\n\n\n\nHost\n\n\n\n\nClone repository\n\n\nClone submodules: \ngit submodule update --init --recursive\n\n\nRun cmake:\n\n\n\n\ncmake . \\\n    -DSYNTAX_ERRORS=\"resources/src/syntax_errors.json\"\\\n    -DSYNTAX_GRAMMAR=\"resources/src/grammar.json\"\\\n    -DLEXICAL_ERRORS=\"resources/src/lexical_errors.json\"\\\n    -DLEXICAL_CONFIG=\"resources/src/lexical_config.json\"\\\n    -DLEXICAL_STATE_MACHINE=\"resources/src/lexical_graph.json\"\n\n\n\n\n\n\nRun make (developer mode):\n\n\n\n\nmake bashcdev\n\n\n\n\n\n\nRun make (production mode):\n\n\n\n\nmake generate_files # Embed JSON configurations into C++ files\n# Run the `cmake` command again to include the generated files\n# cmake . ...\nmake bashc\n\n\n\n\nUsage\n\n\nDeveloper mode\n\n\n./bin/bashcdev \\\n    -s resources/src/lexical_graph.json \\\n    -c resources/src/lexical_config.json \\\n    -e resources/src/lexical_errors.json \\\n    -g resources/src/grammar.json \\\n    -E resources/src/syntax_errors.json \\\n    -o /tmp/test.sh \\\n    -v \\\n    path/to/file1 path/to/file2 ...\n\n\n\n\nProduction mode\n\n\n./bin/bashc -o gen_bash.sh \\\n    path/to/file1 path/to/file2 ... \n\n\n\n\nIn production mode the list of files to compile can be stored in a file (e.g. \nfiles.list\n) and then passed to the application prefixed by an \n@\n symbol. (e.g. \n./bin/bashc @files.list -o /tmp/test.sh\n)\n\n\nLimitations\n\n\n\n\nThe application was tested only on Arch and Ubuntu\n\n\nNot much input files has been written to test the application\n\n\nProject was created for fun and is not guaranteed to work everywhere, unless users prove the opposite ;)\n\n\n\n\nContribution\n\n\n\n\nFeel free to contribute",
            "title": "Home"
        },
        {
            "location": "/#github",
            "text": "Link:  https://github.com/amirbawab/BashClass",
            "title": "Github"
        },
        {
            "location": "/#about",
            "text": "BashClass is a programming language supporting Object Oriented Programming, and compiles into BASH 4.4. Classes and members written in BashClass are converted into associative arrays with unique indices in the generated BASH script.   BashClass uses  EasyCC-C++  library which provides the lexical and syntax analysis. The lexical and syntax analysis configuration files, located under the resources directory, serve as input to EasyCC-C++ to parse the user files and validate it against a grammar determining the language syntax.",
            "title": "About"
        },
        {
            "location": "/#build-project",
            "text": "",
            "title": "Build project"
        },
        {
            "location": "/#docker",
            "text": "Clone repository  Build image:  sudo docker build -t bashclass:latest .  Run container:  docker run --name bashclass-tutorial -it bashclass:latest",
            "title": "Docker"
        },
        {
            "location": "/#host",
            "text": "Clone repository  Clone submodules:  git submodule update --init --recursive  Run cmake:   cmake . \\\n    -DSYNTAX_ERRORS=\"resources/src/syntax_errors.json\"\\\n    -DSYNTAX_GRAMMAR=\"resources/src/grammar.json\"\\\n    -DLEXICAL_ERRORS=\"resources/src/lexical_errors.json\"\\\n    -DLEXICAL_CONFIG=\"resources/src/lexical_config.json\"\\\n    -DLEXICAL_STATE_MACHINE=\"resources/src/lexical_graph.json\"   Run make (developer mode):   make bashcdev   Run make (production mode):   make generate_files # Embed JSON configurations into C++ files\n# Run the `cmake` command again to include the generated files\n# cmake . ...\nmake bashc",
            "title": "Host"
        },
        {
            "location": "/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/#developer-mode",
            "text": "./bin/bashcdev \\\n    -s resources/src/lexical_graph.json \\\n    -c resources/src/lexical_config.json \\\n    -e resources/src/lexical_errors.json \\\n    -g resources/src/grammar.json \\\n    -E resources/src/syntax_errors.json \\\n    -o /tmp/test.sh \\\n    -v \\\n    path/to/file1 path/to/file2 ...",
            "title": "Developer mode"
        },
        {
            "location": "/#production-mode",
            "text": "./bin/bashc -o gen_bash.sh \\\n    path/to/file1 path/to/file2 ...   In production mode the list of files to compile can be stored in a file (e.g.  files.list ) and then passed to the application prefixed by an  @  symbol. (e.g.  ./bin/bashc @files.list -o /tmp/test.sh )",
            "title": "Production mode"
        },
        {
            "location": "/#limitations",
            "text": "The application was tested only on Arch and Ubuntu  Not much input files has been written to test the application  Project was created for fun and is not guaranteed to work everywhere, unless users prove the opposite ;)",
            "title": "Limitations"
        },
        {
            "location": "/#contribution",
            "text": "Feel free to contribute",
            "title": "Contribution"
        },
        {
            "location": "/BashClass_to_Bash/",
            "text": "BashClass to Bash\n\n\nHow it works?\n\n\nIntroduction\n\n\nBashClass syntax is close to other programming languages like C++ and Java, however, instead of compiling to machine code or bytecode, BashClass compiles to Bash.\n\n\nClasses\n\n\nCreating classes in Bash is not possible, but since Bash 4.0, the language added associative arrays which can be used as an alternative way to store a structure of an object. Using this feature, one can keep track of \"objects\" by assigning them a unique id as part of the key. A key is usually composed of two parts: the object id and the member name of the object. \n\n\nFunctions\n\n\nFunctions in BashClass are converted to Bash functions in the generated Bash script. Each statement in a BashClass function is also converted to its corresponding Bash representation while maintaining the original order.\n\n\nType checking\n\n\nBashClass performs type checking at compile time. An expression can be forced to be of a specific type by casting it. The type of an object can also be checked at runtime (Please refer to the example files in the \nexample\n page for further details).\n\n\nReference\n\n\nAn object variable that is initialized in BashClass (using the \nnew\n keyword) stores the unique id of the created object.\n\n\nExpressions\n\n\nExpressions in BashClass are generated step by step following the same operator precedence used in bash.\n\n\nReturn\n\n\nBashClass function can be of any type or void. In the generated bash script, the function call passes an additional argument by reference which will hold the \"returned\" value.\n\n\nArrays\n\n\nBashClass achieves  multi-dimensional arrays using associative arrays in bash where a key is a combination of the indices concatenated by a delimiter.\n\n\nGenerated code example\n\n\nCode in BashClass\n\n\nclass Square {\n    var int side;\n    constructor Square(var int side=0) {\n        this.side = side;\n    }\n\n    function int getArea() {\n        return side * side;\n    }\n}\n\nfunction void print(var int num) {\n    ># echo $1\n}\n\nfunction int main() {\n    var Square sq = new Square(10);\n    print(sq.getArea());\n    return 0;\n}\n\n\n\n\nGenerated BASH script\n\n\n#!/bin/bash\n#\n# Bash version 4.4+ required!\n# This code is auto generated by bashc, do not make manual changes\n# -----------------------------------------------------------------\n# Initialize array counter\n_array_uid_=1\n\n# Initialize class object counter\n_object_uid_=1\ndeclare -A _object_\n\n############# BASH FUNCTIONS ##############\n# Create array\nfunction _bash_createArray() {\n    declare -n _return_=${1}\n    declare -g -A \"_array_${_array_uid_}\"\n    _return_=${_array_uid_}\n    _array_uid_=$(( ${_array_uid_} + 1 ))\n}\n# Convert strings into char array\nfunction _bash_StrToCharArray() {\n    declare string=\"${1}\"\n    declare -n _return_=${2}\n    _bash_createArray _tmp_return_\n    _return_=${_tmp_return_}\n    declare index=0\n    declare -n indexValue=\"_array_${_return_}\"\n    while (( ${index} < ${#string} )); do\n        indexValue[${index}]=${string:${index}:1}\n        index=$(( ${index} + 1 ))\n    done\n}\n###########################################\n\n# Create function\nfunction _c_Square_f_Square() {\n    declare _args_counter_=1\n\n    # Create argument with a default value\n    if (( 0 < $(( ${#} - 0 )) )); then\n    declare _c_Square_f_Square_p_side=\"${1}\"\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n    else\n    declare _c_Square_f_Square_p_side=0\n    declare -n _result_0=_c_Square_f_Square_p_side\n    _result_0=0\n    declare _expression_0=\"${_result_0:-0}\"\n    _c_Square_f_Square_p_side=${_expression_0:-0}\n    fi\n\n    # Configure 'this'\n    declare _this_=${!_args_counter_}\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n\n    # Configure return statement\n    declare -n _return_=${!_args_counter_}\n\n    # Declare member\n    _object_[${_this_},\"_c_Square_v_side\"]=0\n\n    # Header info\n    [[ -v _object_[${_this_},\"__type__\"] ]] || _object_[${_this_},\"__type__\"]=\"Square\"\n    # Evaluate expression\n    declare _result_1=${_this_}\n    declare -n _result_2=_object_[${_result_1},\"_c_Square_v_side\"]\n    declare -n _result_3=_c_Square_f_Square_p_side\n    _result_2=${_result_3:-0}\n    declare _expression_1=\"${_result_2:-0}\"\n\n    # Return statement\n    _return_=${_this_}\n}\n\n# Create function\nfunction _c_Square_f_getArea() {\n    declare _args_counter_=1\n\n    # Configure 'this'\n    declare _this_=${!_args_counter_}\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n\n    # Configure return statement\n    declare -n _return_=${!_args_counter_}\n\n    # Return statement\n    declare -n _result_4=_object_[${_this_},\"_c_Square_v_side\"]\n    declare -n _result_5=_object_[${_this_},\"_c_Square_v_side\"]\n    declare _expression_2=$(( ${_result_4:-0} * ${_result_5:-0} ))\n    _return_=${_expression_2:-0}\n    return\n}\n\n# Create function\nfunction _f_print() {\n    declare _args_counter_=1\n\n    # Create argument\n    declare _f_print_p_num=\"${1}\"\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n\n    # Run BASH code\n     echo $1\n}\n\n# Create function\nfunction _f_main() {\n    declare _args_counter_=1\n\n    # Configure return statement\n    declare -n _return_=${!_args_counter_}\n\n    # Create variable\n    declare _f_main_v_sq=0\n\n    # Initialize variable\n    declare -n _result_6=_f_main_v_sq\n    declare _result_7\n    _c_Square_f_Square \"10\" $(( _object_uid_++ )) _tmp_return_\n    _result_7=${_tmp_return_}\n    _result_6=${_result_7:-0}\n    declare _expression_3=\"${_result_6:-0}\"\n\n    # Evaluate expression\n    declare -n _result_8=_f_main_v_sq\n    declare _result_9\n    _c_Square_f_getArea ${_result_8} _tmp_return_\n    _result_9=${_tmp_return_}\n    _f_print \"${_result_9:-0}\"\n\n    # Return statement\n    _return_=0\n    return\n}\n\n# Run main function\n_f_main _main_return_\nexit ${_main_return_}\n\n# -----------------------------------------------------------------",
            "title": "BashClass to Bash"
        },
        {
            "location": "/BashClass_to_Bash/#bashclass-to-bash",
            "text": "",
            "title": "BashClass to Bash"
        },
        {
            "location": "/BashClass_to_Bash/#how-it-works",
            "text": "",
            "title": "How it works?"
        },
        {
            "location": "/BashClass_to_Bash/#introduction",
            "text": "BashClass syntax is close to other programming languages like C++ and Java, however, instead of compiling to machine code or bytecode, BashClass compiles to Bash.",
            "title": "Introduction"
        },
        {
            "location": "/BashClass_to_Bash/#classes",
            "text": "Creating classes in Bash is not possible, but since Bash 4.0, the language added associative arrays which can be used as an alternative way to store a structure of an object. Using this feature, one can keep track of \"objects\" by assigning them a unique id as part of the key. A key is usually composed of two parts: the object id and the member name of the object.",
            "title": "Classes"
        },
        {
            "location": "/BashClass_to_Bash/#functions",
            "text": "Functions in BashClass are converted to Bash functions in the generated Bash script. Each statement in a BashClass function is also converted to its corresponding Bash representation while maintaining the original order.",
            "title": "Functions"
        },
        {
            "location": "/BashClass_to_Bash/#type-checking",
            "text": "BashClass performs type checking at compile time. An expression can be forced to be of a specific type by casting it. The type of an object can also be checked at runtime (Please refer to the example files in the  example  page for further details).",
            "title": "Type checking"
        },
        {
            "location": "/BashClass_to_Bash/#reference",
            "text": "An object variable that is initialized in BashClass (using the  new  keyword) stores the unique id of the created object.",
            "title": "Reference"
        },
        {
            "location": "/BashClass_to_Bash/#expressions",
            "text": "Expressions in BashClass are generated step by step following the same operator precedence used in bash.",
            "title": "Expressions"
        },
        {
            "location": "/BashClass_to_Bash/#return",
            "text": "BashClass function can be of any type or void. In the generated bash script, the function call passes an additional argument by reference which will hold the \"returned\" value.",
            "title": "Return"
        },
        {
            "location": "/BashClass_to_Bash/#arrays",
            "text": "BashClass achieves  multi-dimensional arrays using associative arrays in bash where a key is a combination of the indices concatenated by a delimiter.",
            "title": "Arrays"
        },
        {
            "location": "/BashClass_to_Bash/#generated-code-example",
            "text": "",
            "title": "Generated code example"
        },
        {
            "location": "/BashClass_to_Bash/#code-in-bashclass",
            "text": "class Square {\n    var int side;\n    constructor Square(var int side=0) {\n        this.side = side;\n    }\n\n    function int getArea() {\n        return side * side;\n    }\n}\n\nfunction void print(var int num) {\n    ># echo $1\n}\n\nfunction int main() {\n    var Square sq = new Square(10);\n    print(sq.getArea());\n    return 0;\n}",
            "title": "Code in BashClass"
        },
        {
            "location": "/BashClass_to_Bash/#generated-bash-script",
            "text": "#!/bin/bash\n#\n# Bash version 4.4+ required!\n# This code is auto generated by bashc, do not make manual changes\n# -----------------------------------------------------------------\n# Initialize array counter\n_array_uid_=1\n\n# Initialize class object counter\n_object_uid_=1\ndeclare -A _object_\n\n############# BASH FUNCTIONS ##############\n# Create array\nfunction _bash_createArray() {\n    declare -n _return_=${1}\n    declare -g -A \"_array_${_array_uid_}\"\n    _return_=${_array_uid_}\n    _array_uid_=$(( ${_array_uid_} + 1 ))\n}\n# Convert strings into char array\nfunction _bash_StrToCharArray() {\n    declare string=\"${1}\"\n    declare -n _return_=${2}\n    _bash_createArray _tmp_return_\n    _return_=${_tmp_return_}\n    declare index=0\n    declare -n indexValue=\"_array_${_return_}\"\n    while (( ${index} < ${#string} )); do\n        indexValue[${index}]=${string:${index}:1}\n        index=$(( ${index} + 1 ))\n    done\n}\n###########################################\n\n# Create function\nfunction _c_Square_f_Square() {\n    declare _args_counter_=1\n\n    # Create argument with a default value\n    if (( 0 < $(( ${#} - 0 )) )); then\n    declare _c_Square_f_Square_p_side=\"${1}\"\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n    else\n    declare _c_Square_f_Square_p_side=0\n    declare -n _result_0=_c_Square_f_Square_p_side\n    _result_0=0\n    declare _expression_0=\"${_result_0:-0}\"\n    _c_Square_f_Square_p_side=${_expression_0:-0}\n    fi\n\n    # Configure 'this'\n    declare _this_=${!_args_counter_}\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n\n    # Configure return statement\n    declare -n _return_=${!_args_counter_}\n\n    # Declare member\n    _object_[${_this_},\"_c_Square_v_side\"]=0\n\n    # Header info\n    [[ -v _object_[${_this_},\"__type__\"] ]] || _object_[${_this_},\"__type__\"]=\"Square\"\n    # Evaluate expression\n    declare _result_1=${_this_}\n    declare -n _result_2=_object_[${_result_1},\"_c_Square_v_side\"]\n    declare -n _result_3=_c_Square_f_Square_p_side\n    _result_2=${_result_3:-0}\n    declare _expression_1=\"${_result_2:-0}\"\n\n    # Return statement\n    _return_=${_this_}\n}\n\n# Create function\nfunction _c_Square_f_getArea() {\n    declare _args_counter_=1\n\n    # Configure 'this'\n    declare _this_=${!_args_counter_}\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n\n    # Configure return statement\n    declare -n _return_=${!_args_counter_}\n\n    # Return statement\n    declare -n _result_4=_object_[${_this_},\"_c_Square_v_side\"]\n    declare -n _result_5=_object_[${_this_},\"_c_Square_v_side\"]\n    declare _expression_2=$(( ${_result_4:-0} * ${_result_5:-0} ))\n    _return_=${_expression_2:-0}\n    return\n}\n\n# Create function\nfunction _f_print() {\n    declare _args_counter_=1\n\n    # Create argument\n    declare _f_print_p_num=\"${1}\"\n    _args_counter_=$(( ${_args_counter_} + 1 ))\n\n    # Run BASH code\n     echo $1\n}\n\n# Create function\nfunction _f_main() {\n    declare _args_counter_=1\n\n    # Configure return statement\n    declare -n _return_=${!_args_counter_}\n\n    # Create variable\n    declare _f_main_v_sq=0\n\n    # Initialize variable\n    declare -n _result_6=_f_main_v_sq\n    declare _result_7\n    _c_Square_f_Square \"10\" $(( _object_uid_++ )) _tmp_return_\n    _result_7=${_tmp_return_}\n    _result_6=${_result_7:-0}\n    declare _expression_3=\"${_result_6:-0}\"\n\n    # Evaluate expression\n    declare -n _result_8=_f_main_v_sq\n    declare _result_9\n    _c_Square_f_getArea ${_result_8} _tmp_return_\n    _result_9=${_tmp_return_}\n    _f_print \"${_result_9:-0}\"\n\n    # Return statement\n    _return_=0\n    return\n}\n\n# Run main function\n_f_main _main_return_\nexit ${_main_return_}\n\n# -----------------------------------------------------------------",
            "title": "Generated BASH script"
        },
        {
            "location": "/example/",
            "text": "Example project\n\n\nProject structure\n\n\nexample\n\u251c\u2500\u2500 files.list\n\u251c\u2500\u2500 input\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Tutorial.bc\n\u2514\u2500\u2500 lib\n \u00a0\u00a0 \u251c\u2500\u2500 Integer.bc\n\u00a0 \u00a0 \u251c\u2500\u2500 List.bc\n\u00a0 \u00a0 \u251c\u2500\u2500 Object.bc\n\u00a0 \u00a0 \u251c\u2500\u2500 String.bc\n\u00a0 \u00a0 \u2514\u2500\u2500 Utils.bc\n\n\n\n\n\n\nThe \nmain\n function is located in \nTutorial.bc\n file.\n\n\nFiles in \nlibs/\n contain data structures and helper functions.\n\n\n\n\nPrerequisite\n\n\n\n\nBuild BashClass. For more details check the \nhome page\n.\n\n\n\n\nCompile files\n\n\ncd example\n../bin/bashc @files.list -o tutorial.sh\n\n\n\n\nRun generated bash script\n\n\n./tutorial.sh \"James\"\n\nHi, James\nLet's do some examples ...\nWant to do 'List' example? (y/n)\n> y\nAdd items to a list. Type exit to stop.\n> Apple\n> Orange\n> exit\nTotal number of items added to the list: 2\nWant to do 'Casting' example? (y/n)\n> y\nAdding the following two items to a list: 123, \"Orange\"\nPrinting items: \nItem at index 0 is an Integer\n123\nItem at index 1 is a String\nOrange\nCongratulations James! You've completed all the examples!\nThank you for trying BashClass :)",
            "title": "Example"
        },
        {
            "location": "/example/#example-project",
            "text": "",
            "title": "Example project"
        },
        {
            "location": "/example/#project-structure",
            "text": "example\n\u251c\u2500\u2500 files.list\n\u251c\u2500\u2500 input\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Tutorial.bc\n\u2514\u2500\u2500 lib\n \u00a0\u00a0 \u251c\u2500\u2500 Integer.bc\n\u00a0 \u00a0 \u251c\u2500\u2500 List.bc\n\u00a0 \u00a0 \u251c\u2500\u2500 Object.bc\n\u00a0 \u00a0 \u251c\u2500\u2500 String.bc\n\u00a0 \u00a0 \u2514\u2500\u2500 Utils.bc   The  main  function is located in  Tutorial.bc  file.  Files in  libs/  contain data structures and helper functions.",
            "title": "Project structure"
        },
        {
            "location": "/example/#prerequisite",
            "text": "Build BashClass. For more details check the  home page .",
            "title": "Prerequisite"
        },
        {
            "location": "/example/#compile-files",
            "text": "cd example\n../bin/bashc @files.list -o tutorial.sh",
            "title": "Compile files"
        },
        {
            "location": "/example/#run-generated-bash-script",
            "text": "./tutorial.sh \"James\"\n\nHi, James\nLet's do some examples ...\nWant to do 'List' example? (y/n)\n> y\nAdd items to a list. Type exit to stop.\n> Apple\n> Orange\n> exit\nTotal number of items added to the list: 2\nWant to do 'Casting' example? (y/n)\n> y\nAdding the following two items to a list: 123, \"Orange\"\nPrinting items: \nItem at index 0 is an Integer\n123\nItem at index 1 is a String\nOrange\nCongratulations James! You've completed all the examples!\nThank you for trying BashClass :)",
            "title": "Run generated bash script"
        },
        {
            "location": "/syntax/",
            "text": "Variable\n\n\nvar int id;\n\n\n\n\n\n\nVariable must have a type.\n\n\nVariable can be initialized when declared.\n\n\n\n\nFunction\n\n\nfunction void myFunction(var int arg1=0) {\n    // body\n}\n\n\n\n\n\n\nFunction must have a type.\n\n\nParameters can have default values.\n\n\nEach program must have a \nmain\n function of type \nint\n with:\n\n\nNo parameters, or\n\n\nvar int argc, var char[][] argv\n\n\n\n\n\n\n\n\nFor loop\n\n\nvar int i;\nfor(i=0; i < 10; i=i+1) {\n    // body\n}\n\n\n\n\n\n\nThe counter must be declared before the for loop statement.\n\n\n\n\nWhile loop\n\n\nwhile(true) {\n    // body\n}\n\n\n\n\nIf, Elif and Else\n\n\nif(condition1) {\n    // body1\n} elif( condition2) {\n    // body2\n} else {\n    // body3\n}\n\n\n\n\nClass\n\n\nclass MyClass {\n    constructor MyClass() {\n        // body\n    }\n    // functions and variables\n}\n\n\n\n\n\n\nOne constructor function is required for each class and must share the class name.\n\n\nA class can have \nfunctions\n and \nvariables\n.\n\n\nAll class members for instances are accessible.\n\n\n\n\nInheritance\n\n\nclass Child extends Parent {\n    constructor Child() {\n        super_constructor();\n        // body\n    }\n}\n\n\n\n\n\n\nParent constructor must be called from child constructor\n\n\n\n\nArrays\n\n\nvar MyClass[] data = new MyClass[];\n\n\n\n\n\n\nMulti-dimensional arrays are created similarly\n\n\n\n\nCasting\n\n\nvar int fakeInt = ('a'):int;\n\n\n\n\n\n\nVariable \nfakeInt\n will not convert \na\n to its corresponding ascii number, instead it will just trick the compiler to think it holds an \nint\n. \n\n\nCasting to wrong types might lead to an undefined behavior (example above).\n\n\n\n\nBash code\n\n\nInline bash script\n\n\n># echo Hello world\n\n\n\n\nBlock of bash script\n\n\n>@\n    echo Hello\n    echo World\n@<\n\n\n\n\nSubshell char[]\n\n\nvar char[] helloWorld = >$echo hello world$<;\n\n\n\n\n\n\nEquivalent to: \nhelloWorld=\"$(echo hello world)\"\n\n\n\n\nSubshell int\n\n\nvar int one = >%echo 1%<;\n\n\n\n\n\n\nEquivalent to: \none=\"$(echo 1)\"",
            "title": "Syntax"
        },
        {
            "location": "/syntax/#variable",
            "text": "var int id;   Variable must have a type.  Variable can be initialized when declared.",
            "title": "Variable"
        },
        {
            "location": "/syntax/#function",
            "text": "function void myFunction(var int arg1=0) {\n    // body\n}   Function must have a type.  Parameters can have default values.  Each program must have a  main  function of type  int  with:  No parameters, or  var int argc, var char[][] argv",
            "title": "Function"
        },
        {
            "location": "/syntax/#for-loop",
            "text": "var int i;\nfor(i=0; i < 10; i=i+1) {\n    // body\n}   The counter must be declared before the for loop statement.",
            "title": "For loop"
        },
        {
            "location": "/syntax/#while-loop",
            "text": "while(true) {\n    // body\n}",
            "title": "While loop"
        },
        {
            "location": "/syntax/#if-elif-and-else",
            "text": "if(condition1) {\n    // body1\n} elif( condition2) {\n    // body2\n} else {\n    // body3\n}",
            "title": "If, Elif and Else"
        },
        {
            "location": "/syntax/#class",
            "text": "class MyClass {\n    constructor MyClass() {\n        // body\n    }\n    // functions and variables\n}   One constructor function is required for each class and must share the class name.  A class can have  functions  and  variables .  All class members for instances are accessible.",
            "title": "Class"
        },
        {
            "location": "/syntax/#inheritance",
            "text": "class Child extends Parent {\n    constructor Child() {\n        super_constructor();\n        // body\n    }\n}   Parent constructor must be called from child constructor",
            "title": "Inheritance"
        },
        {
            "location": "/syntax/#arrays",
            "text": "var MyClass[] data = new MyClass[];   Multi-dimensional arrays are created similarly",
            "title": "Arrays"
        },
        {
            "location": "/syntax/#casting",
            "text": "var int fakeInt = ('a'):int;   Variable  fakeInt  will not convert  a  to its corresponding ascii number, instead it will just trick the compiler to think it holds an  int .   Casting to wrong types might lead to an undefined behavior (example above).",
            "title": "Casting"
        },
        {
            "location": "/syntax/#bash-code",
            "text": "",
            "title": "Bash code"
        },
        {
            "location": "/syntax/#inline-bash-script",
            "text": "># echo Hello world",
            "title": "Inline bash script"
        },
        {
            "location": "/syntax/#block-of-bash-script",
            "text": ">@\n    echo Hello\n    echo World\n@<",
            "title": "Block of bash script"
        },
        {
            "location": "/syntax/#subshell-char",
            "text": "var char[] helloWorld = >$echo hello world$<;   Equivalent to:  helloWorld=\"$(echo hello world)\"",
            "title": "Subshell char[]"
        },
        {
            "location": "/syntax/#subshell-int",
            "text": "var int one = >%echo 1%<;   Equivalent to:  one=\"$(echo 1)\"",
            "title": "Subshell int"
        }
    ]
}